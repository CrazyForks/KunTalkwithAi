package com.example.app1.data.models // Or data.network if you prefer

import kotlinx.serialization.Serializable
import kotlinx.serialization.SerialName
import kotlinx.serialization.Contextual // Import if using Contextual Any for arguments

// Represents a single chunk received from the SSE stream
@Serializable // Ensure it's serializable
data class StreamChunk(
    @SerialName("type") // "content", "reasoning", "error", or "tool_call"
    val type: String,

    // Text is now nullable as "tool_call" chunks won't have it at the top level
    @SerialName("text")
    val text: String? = null,

    // New field to hold the payload for "tool_call" type chunks
    @SerialName("tool_call") // Matches the JSON key from the backend
    val toolCall: ToolCallPayload? = null // Nullable, only present for type="tool_call"
)

// Represents the nested 'tool_call' structure within the StreamChunk
@Serializable
data class ToolCallPayload(
    @SerialName("id") // Matches backend JSON
    val id: String, // The unique ID generated by the backend for this call

    @SerialName("function") // Matches backend JSON
    val function: ToolCallFunction
)

// Represents the nested 'function' structure within the ToolCallPayload
@Serializable
data class ToolCallFunction(
    @SerialName("name") // Matches backend JSON
    val name: String, // The name of the function to be called

    // Arguments received from the backend (usually a JSON object parsed into a Map)
    @SerialName("arguments")
    // Using @Contextual Any to handle potentially mixed types in arguments.
    // Ensure your Json serializer is configured for this, or consider using JsonElement.
    val arguments: Map<String, @Contextual Any>
)